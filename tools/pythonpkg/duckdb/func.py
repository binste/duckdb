# NOTE: This file is automatically generated by tools/pythonpkg/scripts/generate_functions_code.py.
# Do not edit this section manually, your changes will be overwritten!

from typing import List


from duckdb.duckdb import FunctionExpression, Expression


class _UndefinedType:
    """A singleton object for marking undefined parameters"""

    __instance = None

    def __new__(cls, *args, **kwargs):
        if not isinstance(cls.__instance, cls):
            cls.__instance = object.__new__(cls, *args, **kwargs)
        return cls.__instance

    def __repr__(self):
        return "Undefined"


_UNDEFINED = _UndefinedType()


def _remove_undefined_parameters(*parameters) -> List:
    return [p for p in parameters if p is not _UNDEFINED]


def abs(x, /) -> Expression:
    """Absolute value"""
    return FunctionExpression("abs", x)


def acos(x, /) -> Expression:
    """Computes the arccosine of x"""
    return FunctionExpression("acos", x)


def acosh(x, /) -> Expression:
    """Computes the inverse hyperbolic cos of x"""
    return FunctionExpression("acosh", x)


def add(col0, col1=_UNDEFINED, /) -> Expression:
    """"""
    return FunctionExpression("add", *_remove_undefined_parameters(col0, col1))


def age(timestamp1, timestamp2=_UNDEFINED, /) -> Expression:
    """Subtract arguments, resulting in the time difference between the two timestamps"""
    return FunctionExpression("age", *_remove_undefined_parameters(timestamp1, timestamp2))


def aggregate(*args) -> Expression:
    """Executes the aggregate function name on the elements of list"""
    return FunctionExpression("aggregate", *args)


def alias(expr, /) -> Expression:
    """Returns the name of a given expression"""
    return FunctionExpression("alias", expr)


def any_value(col0, /) -> Expression:
    """"""
    return FunctionExpression("any_value", col0)


def approx_count_distinct(any, /) -> Expression:
    """Computes the approximate count of distinct elements using HyperLogLog."""
    return FunctionExpression("approx_count_distinct", any)


def approx_quantile(x, pos, /) -> Expression:
    """Computes the approximate quantile using T-Digest."""
    return FunctionExpression("approx_quantile", x, pos)


def approx_top_k(val, k, /) -> Expression:
    """Finds the k approximately most occurring values in the data set"""
    return FunctionExpression("approx_top_k", val, k)


def arbitrary(col0, /) -> Expression:
    """"""
    return FunctionExpression("arbitrary", col0)


def arg_max(arg, val, col2=_UNDEFINED, /) -> Expression:
    """Finds the row with the maximum val. Calculates the non-NULL arg expression at
    that row."""
    return FunctionExpression("arg_max", *_remove_undefined_parameters(arg, val, col2))


def arg_max_null(arg, val, /) -> Expression:
    """Finds the row with the maximum val. Calculates the arg expression at that row."""
    return FunctionExpression("arg_max_null", arg, val)


def arg_min(arg, val, col2=_UNDEFINED, /) -> Expression:
    """Finds the row with the minimum val. Calculates the non-NULL arg expression at
    that row."""
    return FunctionExpression("arg_min", *_remove_undefined_parameters(arg, val, col2))


def arg_min_null(arg, val, /) -> Expression:
    """Finds the row with the minimum val. Calculates the arg expression at that row."""
    return FunctionExpression("arg_min_null", arg, val)


def argmax(arg, val, col2=_UNDEFINED, /) -> Expression:
    """Finds the row with the maximum val. Calculates the non-NULL arg expression at
    that row."""
    return FunctionExpression("argmax", *_remove_undefined_parameters(arg, val, col2))


def argmin(arg, val, col2=_UNDEFINED, /) -> Expression:
    """Finds the row with the minimum val. Calculates the non-NULL arg expression at
    that row."""
    return FunctionExpression("argmin", *_remove_undefined_parameters(arg, val, col2))


def array_agg(arg, /) -> Expression:
    """Returns a LIST containing all the values of a column."""
    return FunctionExpression("array_agg", arg)


def array_aggr(*args) -> Expression:
    """Executes the aggregate function name on the elements of list"""
    return FunctionExpression("array_aggr", *args)


def array_aggregate(*args) -> Expression:
    """Executes the aggregate function name on the elements of list"""
    return FunctionExpression("array_aggregate", *args)


def array_append(arr, el, /) -> Expression:
    """"""
    return FunctionExpression("array_append", arr, el)


def array_cat(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("array_cat", col0, col1)


def array_concat(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("array_concat", col0, col1)


def array_contains(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("array_contains", col0, col1)


def array_cosine_distance(array1, array2, /) -> Expression:
    """Compute the cosine distance between two arrays of the same size. The array
    elements can not be NULL. The arrays can have any size as long as the size
    is the same for both arguments."""
    return FunctionExpression("array_cosine_distance", array1, array2)


def array_cosine_similarity(array1, array2, /) -> Expression:
    """Compute the cosine similarity between two arrays of the same size. The array
    elements can not be NULL. The arrays can have any size as long as the size
    is the same for both arguments."""
    return FunctionExpression("array_cosine_similarity", array1, array2)


def array_cross_product(array1, array2, /) -> Expression:
    """Compute the cross product of two arrays of size 3. The array elements can not be
    NULL."""
    return FunctionExpression("array_cross_product", array1, array2)


def array_distance(array1, array2, /) -> Expression:
    """Compute the distance between two arrays of the same size. The array elements can
    not be NULL. The arrays can have any size as long as the size is the same
    for both arguments."""
    return FunctionExpression("array_distance", array1, array2)


def array_distinct(list, /) -> Expression:
    """Removes all duplicates and NULLs from a list. Does not preserve the original
    order"""
    return FunctionExpression("array_distinct", list)


def array_dot_product(array1, array2, /) -> Expression:
    """Compute the inner product between two arrays of the same size. The array
    elements can not be NULL. The arrays can have any size as long as the size
    is the same for both arguments."""
    return FunctionExpression("array_dot_product", array1, array2)


def array_extract(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("array_extract", col0, col1)


def array_grade_up(list, col1=_UNDEFINED, col2=_UNDEFINED, /) -> Expression:
    """Returns the index of their sorted position."""
    return FunctionExpression("array_grade_up", *_remove_undefined_parameters(list, col1, col2))


def array_has(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("array_has", col0, col1)


def array_has_all(l1, l2, /) -> Expression:
    """Returns true if all elements of l2 are in l1. NULLs are ignored."""
    return FunctionExpression("array_has_all", l1, l2)


def array_has_any(l1, l2, /) -> Expression:
    """Returns true if the lists have any element in common. NULLs are ignored."""
    return FunctionExpression("array_has_any", l1, l2)


def array_indexof(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("array_indexof", col0, col1)


def array_inner_product(array1, array2, /) -> Expression:
    """Compute the inner product between two arrays of the same size. The array
    elements can not be NULL. The arrays can have any size as long as the size
    is the same for both arguments."""
    return FunctionExpression("array_inner_product", array1, array2)


def array_intersect(l1, l2, /) -> Expression:
    """"""
    return FunctionExpression("array_intersect", l1, l2)


def array_length(col0, col1=_UNDEFINED, /) -> Expression:
    """"""
    return FunctionExpression("array_length", *_remove_undefined_parameters(col0, col1))


def array_negative_dot_product(array1, array2, /) -> Expression:
    """Compute the negative inner product between two arrays of the same size. The
    array elements can not be NULL. The arrays can have any size as long as the
    size is the same for both arguments."""
    return FunctionExpression("array_negative_dot_product", array1, array2)


def array_negative_inner_product(array1, array2, /) -> Expression:
    """Compute the negative inner product between two arrays of the same size. The
    array elements can not be NULL. The arrays can have any size as long as the
    size is the same for both arguments."""
    return FunctionExpression("array_negative_inner_product", array1, array2)


def array_pop_back(arr, /) -> Expression:
    """"""
    return FunctionExpression("array_pop_back", arr)


def array_pop_front(arr, /) -> Expression:
    """"""
    return FunctionExpression("array_pop_front", arr)


def array_position(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("array_position", col0, col1)


def array_prepend(el, arr, /) -> Expression:
    """"""
    return FunctionExpression("array_prepend", el, arr)


def array_push_back(arr, e, /) -> Expression:
    """"""
    return FunctionExpression("array_push_back", arr, e)


def array_push_front(arr, e, /) -> Expression:
    """"""
    return FunctionExpression("array_push_front", arr, e)


def array_resize(col0, col1, col2=_UNDEFINED, /) -> Expression:
    """"""
    return FunctionExpression("array_resize", *_remove_undefined_parameters(col0, col1, col2))


def array_reverse(l, /) -> Expression:
    """"""
    return FunctionExpression("array_reverse", l)


def array_reverse_sort(list, col1=_UNDEFINED, /) -> Expression:
    """Sorts the elements of the list in reverse order"""
    return FunctionExpression("array_reverse_sort", *_remove_undefined_parameters(list, col1))


def array_select(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("array_select", col0, col1)


def array_slice(list, begin, end, step=_UNDEFINED, /) -> Expression:
    """Extract a sublist using slice conventions. Negative values are accepted"""
    return FunctionExpression("array_slice", *_remove_undefined_parameters(list, begin, end, step))


def array_sort(list, col1=_UNDEFINED, col2=_UNDEFINED, /) -> Expression:
    """Sorts the elements of the list"""
    return FunctionExpression("array_sort", *_remove_undefined_parameters(list, col1, col2))


def array_to_json(*args) -> Expression:
    """"""
    return FunctionExpression("array_to_json", *args)


def array_to_string(arr, sep, /) -> Expression:
    """"""
    return FunctionExpression("array_to_string", arr, sep)


def array_to_string_comma_default(arr, sep, /) -> Expression:
    """"""
    return FunctionExpression("array_to_string_comma_default", arr, sep)


def array_unique(list, /) -> Expression:
    """Counts the unique elements of a list"""
    return FunctionExpression("array_unique", list)


def array_value(*args) -> Expression:
    """Create an ARRAY containing the argument values."""
    return FunctionExpression("array_value", *args)


def array_where(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("array_where", col0, col1)


def array_zip(*args) -> Expression:
    """"""
    return FunctionExpression("array_zip", *args)


def ascii(string, /) -> Expression:
    """Returns an integer that represents the Unicode code point of the first character
    of the string"""
    return FunctionExpression("ascii", string)


def asin(x, /) -> Expression:
    """Computes the arcsine of x"""
    return FunctionExpression("asin", x)


def asinh(x, /) -> Expression:
    """Computes the inverse hyperbolic sin of x"""
    return FunctionExpression("asinh", x)


def atan(x, /) -> Expression:
    """Computes the arctangent of x"""
    return FunctionExpression("atan", x)


def atan2(y, x, /) -> Expression:
    """Computes the arctangent (y, x)"""
    return FunctionExpression("atan2", y, x)


def atanh(x, /) -> Expression:
    """Computes the inverse hyperbolic tan of x"""
    return FunctionExpression("atanh", x)


def avg(x, /) -> Expression:
    """Calculates the average value for all tuples in x."""
    return FunctionExpression("avg", x)


def bar(x, min, max, width=_UNDEFINED, /) -> Expression:
    """Draws a band whose width is proportional to (x - min) and equal to width
    characters when x = max. width defaults to 80"""
    return FunctionExpression("bar", *_remove_undefined_parameters(x, min, max, width))


def base64(blob, /) -> Expression:
    """Convert a blob to a base64 encoded string"""
    return FunctionExpression("base64", blob)


def bin(value, /) -> Expression:
    """Converts the value to binary representation"""
    return FunctionExpression("bin", value)


def bit_and(arg, /) -> Expression:
    """Returns the bitwise AND of all bits in a given expression."""
    return FunctionExpression("bit_and", arg)


def bit_count(x, /) -> Expression:
    """Returns the number of bits that are set"""
    return FunctionExpression("bit_count", x)


def bit_length(col0, /) -> Expression:
    """"""
    return FunctionExpression("bit_length", col0)


def bit_or(arg, /) -> Expression:
    """Returns the bitwise OR of all bits in a given expression."""
    return FunctionExpression("bit_or", arg)


def bit_position(substring, bitstring, /) -> Expression:
    """Returns first starting index of the specified substring within bits, or zero if
    it is not present. The first (leftmost) bit is indexed 1"""
    return FunctionExpression("bit_position", substring, bitstring)


def bit_xor(arg, /) -> Expression:
    """Returns the bitwise XOR of all bits in a given expression."""
    return FunctionExpression("bit_xor", arg)


def bitstring(bitstring, length, /) -> Expression:
    """Pads the bitstring until the specified length"""
    return FunctionExpression("bitstring", bitstring, length)


def bitstring_agg(arg, col1=_UNDEFINED, col2=_UNDEFINED, /) -> Expression:
    """Returns a bitstring with bits set for each distinct value."""
    return FunctionExpression("bitstring_agg", *_remove_undefined_parameters(arg, col1, col2))


def bool_and(arg, /) -> Expression:
    """Returns TRUE if every input value is TRUE, otherwise FALSE."""
    return FunctionExpression("bool_and", arg)


def bool_or(arg, /) -> Expression:
    """Returns TRUE if any input value is TRUE, otherwise FALSE."""
    return FunctionExpression("bool_or", arg)


def can_cast_implicitly(source_type, target_type, /) -> Expression:
    """Whether or not we can implicitly cast from the source type to the other type"""
    return FunctionExpression("can_cast_implicitly", source_type, target_type)


def cardinality(*args) -> Expression:
    """Returns the size of the map (or the number of entries in the map)"""
    return FunctionExpression("cardinality", *args)


def cbrt(x, /) -> Expression:
    """Returns the cube root of x"""
    return FunctionExpression("cbrt", x)


def ceil(x, /) -> Expression:
    """Rounds the number up"""
    return FunctionExpression("ceil", x)


def ceiling(x, /) -> Expression:
    """Rounds the number up"""
    return FunctionExpression("ceiling", x)


def century(ts, /) -> Expression:
    """Extract the century component from a date or timestamp"""
    return FunctionExpression("century", ts)


def chr(code_point, /) -> Expression:
    """Returns a character which is corresponding the ASCII code value or Unicode code
    point"""
    return FunctionExpression("chr", code_point)


def combine(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("combine", col0, col1)


def concat(*args) -> Expression:
    """"""
    return FunctionExpression("concat", *args)


def concat_ws(*args) -> Expression:
    """"""
    return FunctionExpression("concat_ws", *args)


def constant_or_null(*args) -> Expression:
    """"""
    return FunctionExpression("constant_or_null", *args)


def contains(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("contains", col0, col1)


def corr(y, x, /) -> Expression:
    """Returns the correlation coefficient for non-null pairs in a group."""
    return FunctionExpression("corr", y, x)


def cos(x, /) -> Expression:
    """Computes the cos of x"""
    return FunctionExpression("cos", x)


def cosh(x, /) -> Expression:
    """Computes the hyperbolic cos of x"""
    return FunctionExpression("cosh", x)


def cot(x, /) -> Expression:
    """Computes the cotangent of x"""
    return FunctionExpression("cot", x)


def count(col0=_UNDEFINED, /) -> Expression:
    """"""
    return FunctionExpression("count", *_remove_undefined_parameters(col0))


def count_if(l, /) -> Expression:
    """"""
    return FunctionExpression("count_if", l)


def count_star() -> Expression:
    """"""
    return FunctionExpression("count_star")


def covar_pop(y, x, /) -> Expression:
    """Returns the population covariance of input values."""
    return FunctionExpression("covar_pop", y, x)


def covar_samp(y, x, /) -> Expression:
    """Returns the sample covariance for non-null pairs in a group."""
    return FunctionExpression("covar_samp", y, x)


def create_sort_key(*args) -> Expression:
    """Constructs a binary-comparable sort key based on a set of input parameters and
    sort qualifiers"""
    return FunctionExpression("create_sort_key", *args)


def current_catalog() -> Expression:
    """"""
    return FunctionExpression("current_catalog")


def current_database() -> Expression:
    """Returns the name of the currently active database"""
    return FunctionExpression("current_database")


def current_date() -> Expression:
    """Returns the current date"""
    return FunctionExpression("current_date")


def current_localtime() -> Expression:
    """"""
    return FunctionExpression("current_localtime")


def current_localtimestamp() -> Expression:
    """"""
    return FunctionExpression("current_localtimestamp")


def current_query() -> Expression:
    """Returns the current query as a string"""
    return FunctionExpression("current_query")


def current_role() -> Expression:
    """"""
    return FunctionExpression("current_role")


def current_schema() -> Expression:
    """Returns the name of the currently active schema. Default is main"""
    return FunctionExpression("current_schema")


def current_schemas(include_implicit, /) -> Expression:
    """Returns list of schemas. Pass a parameter of True to include implicit schemas"""
    return FunctionExpression("current_schemas", include_implicit)


def current_setting(setting_name, /) -> Expression:
    """Returns the current value of the configuration setting"""
    return FunctionExpression("current_setting", setting_name)


def current_user() -> Expression:
    """"""
    return FunctionExpression("current_user")


def currval(col0, /) -> Expression:
    """"""
    return FunctionExpression("currval", col0)


def damerau_levenshtein(str1, str2, /) -> Expression:
    """Extension of Levenshtein distance to also include transposition of adjacent
    characters as an allowed edit operation. In other words, the minimum number
    of edit operations (insertions, deletions, substitutions or transpositions)
    required to change one string to another. Different case is considered
    different"""
    return FunctionExpression("damerau_levenshtein", str1, str2)


def date_add(date, interval, /) -> Expression:
    """"""
    return FunctionExpression("date_add", date, interval)


def date_diff(part, startdate, enddate, /) -> Expression:
    """The number of partition boundaries between the timestamps"""
    return FunctionExpression("date_diff", part, startdate, enddate)


def date_part(ts, col1, /) -> Expression:
    """Get subfield (equivalent to extract)"""
    return FunctionExpression("date_part", ts, col1)


def date_sub(part, startdate, enddate, /) -> Expression:
    """The number of complete partitions between the timestamps"""
    return FunctionExpression("date_sub", part, startdate, enddate)


def date_trunc(part, timestamp, /) -> Expression:
    """Truncate to specified precision"""
    return FunctionExpression("date_trunc", part, timestamp)


def datediff(part, startdate, enddate, /) -> Expression:
    """The number of partition boundaries between the timestamps"""
    return FunctionExpression("datediff", part, startdate, enddate)


def datepart(ts, col1, /) -> Expression:
    """Get subfield (equivalent to extract)"""
    return FunctionExpression("datepart", ts, col1)


def datesub(part, startdate, enddate, /) -> Expression:
    """The number of complete partitions between the timestamps"""
    return FunctionExpression("datesub", part, startdate, enddate)


def datetrunc(part, timestamp, /) -> Expression:
    """Truncate to specified precision"""
    return FunctionExpression("datetrunc", part, timestamp)


def day(ts, /) -> Expression:
    """Extract the day component from a date or timestamp"""
    return FunctionExpression("day", ts)


def dayname(ts, /) -> Expression:
    """The (English) name of the weekday"""
    return FunctionExpression("dayname", ts)


def dayofmonth(ts, /) -> Expression:
    """Extract the dayofmonth component from a date or timestamp"""
    return FunctionExpression("dayofmonth", ts)


def dayofweek(ts, /) -> Expression:
    """Extract the dayofweek component from a date or timestamp"""
    return FunctionExpression("dayofweek", ts)


def dayofyear(ts, /) -> Expression:
    """Extract the dayofyear component from a date or timestamp"""
    return FunctionExpression("dayofyear", ts)


def decade(ts, /) -> Expression:
    """Extract the decade component from a date or timestamp"""
    return FunctionExpression("decade", ts)


def decode(blob, /) -> Expression:
    """Convert blob to varchar. Fails if blob is not valid utf-8"""
    return FunctionExpression("decode", blob)


def degrees(x, /) -> Expression:
    """Converts radians to degrees"""
    return FunctionExpression("degrees", x)


def divide(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("divide", col0, col1)


def edit(col0, col1=_UNDEFINED, /) -> Expression:
    """"""
    return FunctionExpression("edit", *_remove_undefined_parameters(col0, col1))


def editdist3(str1, str2, /) -> Expression:
    """The minimum number of single-character edits (insertions, deletions or
    substitutions) required to change one string to the other. Different case is
    considered different"""
    return FunctionExpression("editdist3", str1, str2)


def element_at(*args) -> Expression:
    """Returns a list containing the value for a given key or an empty list if the key
    is not contained in the map. The type of the key provided in the second
    parameter must match the type of the map’s keys else an error is returned"""
    return FunctionExpression("element_at", *args)


def encode(string, /) -> Expression:
    """Convert varchar to blob. Converts utf-8 characters into literal encoding"""
    return FunctionExpression("encode", string)


def ends_with(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("ends_with", col0, col1)


def entropy(x, /) -> Expression:
    """Returns the log-2 entropy of count input-values."""
    return FunctionExpression("entropy", x)


def enum_code(enum, /) -> Expression:
    """Returns the numeric value backing the given enum value"""
    return FunctionExpression("enum_code", enum)


def enum_first(enum, /) -> Expression:
    """Returns the first value of the input enum type"""
    return FunctionExpression("enum_first", enum)


def enum_last(enum, /) -> Expression:
    """Returns the last value of the input enum type"""
    return FunctionExpression("enum_last", enum)


def enum_range(enum, /) -> Expression:
    """Returns all values of the input enum type as an array"""
    return FunctionExpression("enum_range", enum)


def enum_range_boundary(start, end, /) -> Expression:
    """Returns the range between the two given enum values as an array. The values must
    be of the same enum type. When the first parameter is NULL, the result
    starts with the first value of the enum type. When the second parameter is
    NULL, the result ends with the last value of the enum type"""
    return FunctionExpression("enum_range_boundary", start, end)


def epoch(temporal, /) -> Expression:
    """Extract the epoch component from a temporal type"""
    return FunctionExpression("epoch", temporal)


def epoch_ms(temporal, /) -> Expression:
    """Extract the epoch component in milliseconds from a temporal type"""
    return FunctionExpression("epoch_ms", temporal)


def epoch_ns(temporal, /) -> Expression:
    """Extract the epoch component in nanoseconds from a temporal type"""
    return FunctionExpression("epoch_ns", temporal)


def epoch_us(temporal, /) -> Expression:
    """Extract the epoch component in microseconds from a temporal type"""
    return FunctionExpression("epoch_us", temporal)


def equi_width_bins(min, max, bin_count, nice_rounding, /) -> Expression:
    """Generates bin_count equi-width bins between the min and max. If enabled
    nice_rounding makes the numbers more readable/less jagged"""
    return FunctionExpression("equi_width_bins", min, max, bin_count, nice_rounding)


def era(ts, /) -> Expression:
    """Extract the era component from a date or timestamp"""
    return FunctionExpression("era", ts)


def error(message, /) -> Expression:
    """Throws the given error message"""
    return FunctionExpression("error", message)


def even(x, /) -> Expression:
    """Rounds x to next even number by rounding away from zero"""
    return FunctionExpression("even", x)


def exp(x, /) -> Expression:
    """Computes e to the power of x"""
    return FunctionExpression("exp", x)


def factorial(x, /) -> Expression:
    """Factorial of x. Computes the product of the current integer and all integers
    below it"""
    return FunctionExpression("factorial", x)


def favg(x, /) -> Expression:
    """Calculates the average using a more accurate floating point summation (Kahan
    Sum)"""
    return FunctionExpression("favg", x)


def fdiv(x, y, /) -> Expression:
    """"""
    return FunctionExpression("fdiv", x, y)


def finalize(col0, /) -> Expression:
    """"""
    return FunctionExpression("finalize", col0)


def first(col0, /) -> Expression:
    """"""
    return FunctionExpression("first", col0)


def flatten(nested_list, /) -> Expression:
    """Flatten a nested list by one level"""
    return FunctionExpression("flatten", nested_list)


def floor(x, /) -> Expression:
    """Rounds the number down"""
    return FunctionExpression("floor", x)


def fmod(x, y, /) -> Expression:
    """"""
    return FunctionExpression("fmod", x, y)


def format(*args) -> Expression:
    """Formats a string using fmt syntax"""
    return FunctionExpression("format", *args)


def formatReadableDecimalSize(bytes, /) -> Expression:
    """Converts bytes to a human-readable presentation (e.g. 16000 -> 16.0 KB)"""
    return FunctionExpression("formatReadableDecimalSize", bytes)


def formatReadableSize(bytes, /) -> Expression:
    """Converts bytes to a human-readable presentation (e.g. 16000 -> 15.6 KiB)"""
    return FunctionExpression("formatReadableSize", bytes)


def format_bytes(bytes, /) -> Expression:
    """Converts bytes to a human-readable presentation (e.g. 16000 -> 15.6 KiB)"""
    return FunctionExpression("format_bytes", bytes)


def from_base64(string, /) -> Expression:
    """Convert a base64 encoded string to a character string"""
    return FunctionExpression("from_base64", string)


def from_binary(value, /) -> Expression:
    """Converts a value from binary representation to a blob"""
    return FunctionExpression("from_binary", value)


def from_hex(value, /) -> Expression:
    """Converts a value from hexadecimal representation to a blob"""
    return FunctionExpression("from_hex", value)


def from_json(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("from_json", col0, col1)


def from_json_strict(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("from_json_strict", col0, col1)


def fsum(arg, /) -> Expression:
    """Calculates the sum using a more accurate floating point summation (Kahan Sum)."""
    return FunctionExpression("fsum", arg)


def gamma(x, /) -> Expression:
    """Interpolation of (x-1) factorial (so decimal inputs are allowed)"""
    return FunctionExpression("gamma", x)


def gcd(x, y, /) -> Expression:
    """Computes the greatest common divisor of x and y"""
    return FunctionExpression("gcd", x, y)


def gen_random_uuid() -> Expression:
    """Returns a random UUID similar to this: eeccb8c5-9943-b2bb-bb5e-222f4e14b687"""
    return FunctionExpression("gen_random_uuid")


def generate_series(start, stop=_UNDEFINED, step=_UNDEFINED, /) -> Expression:
    """Create a list of values between start and stop - the stop parameter is inclusive"""
    return FunctionExpression("generate_series", *_remove_undefined_parameters(start, stop, step))


def generate_subscripts(arr, dim, /) -> Expression:
    """"""
    return FunctionExpression("generate_subscripts", arr, dim)


def geomean(x, /) -> Expression:
    """"""
    return FunctionExpression("geomean", x)


def geometric_mean(x, /) -> Expression:
    """"""
    return FunctionExpression("geometric_mean", x)


def get_bit(bitstring, index, /) -> Expression:
    """Extracts the nth bit from bitstring; the first (leftmost) bit is indexed 0"""
    return FunctionExpression("get_bit", bitstring, index)


def get_block_size(db_name, /) -> Expression:
    """"""
    return FunctionExpression("get_block_size", db_name)


def get_current_time() -> Expression:
    """Returns the current time"""
    return FunctionExpression("get_current_time")


def get_current_timestamp() -> Expression:
    """Returns the current timestamp"""
    return FunctionExpression("get_current_timestamp")


def getenv(col0, /) -> Expression:
    """"""
    return FunctionExpression("getenv", col0)


def getvariable(col0, /) -> Expression:
    """"""
    return FunctionExpression("getvariable", col0)


def grade_up(list, col1=_UNDEFINED, col2=_UNDEFINED, /) -> Expression:
    """Returns the index of their sorted position."""
    return FunctionExpression("grade_up", *_remove_undefined_parameters(list, col1, col2))


def greatest(*args) -> Expression:
    """Returns the highest value of the set of input parameters"""
    return FunctionExpression("greatest", *args)


def greatest_common_divisor(x, y, /) -> Expression:
    """Computes the greatest common divisor of x and y"""
    return FunctionExpression("greatest_common_divisor", x, y)


def group_concat(str, arg=_UNDEFINED, /) -> Expression:
    """Concatenates the column string values with an optional separator."""
    return FunctionExpression("group_concat", *_remove_undefined_parameters(str, arg))


def hamming(str1, str2, /) -> Expression:
    """The number of positions with different characters for 2 strings of equal length.
    Different case is considered different"""
    return FunctionExpression("hamming", str1, str2)


def hash(*args) -> Expression:
    """Returns an integer with the hash of the value. Note that this is not a
    cryptographic hash"""
    return FunctionExpression("hash", *args)


def hex(value, /) -> Expression:
    """Converts the value to hexadecimal representation"""
    return FunctionExpression("hex", value)


def histogram(arg, col1=_UNDEFINED, /) -> Expression:
    """Returns a LIST of STRUCTs with the fields bucket and count."""
    return FunctionExpression("histogram", *_remove_undefined_parameters(arg, col1))


def histogram_exact(arg, bins, /) -> Expression:
    """Returns a LIST of STRUCTs with the fields bucket and count matching the buckets
    exactly."""
    return FunctionExpression("histogram_exact", arg, bins)


def hour(ts, /) -> Expression:
    """Extract the hour component from a date or timestamp"""
    return FunctionExpression("hour", ts)


def icu_collate_af(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_af", col0)


def icu_collate_am(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_am", col0)


def icu_collate_ar(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_ar", col0)


def icu_collate_ar_sa(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_ar_sa", col0)


def icu_collate_as(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_as", col0)


def icu_collate_az(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_az", col0)


def icu_collate_be(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_be", col0)


def icu_collate_bg(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_bg", col0)


def icu_collate_bn(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_bn", col0)


def icu_collate_bo(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_bo", col0)


def icu_collate_br(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_br", col0)


def icu_collate_bs(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_bs", col0)


def icu_collate_ca(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_ca", col0)


def icu_collate_ceb(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_ceb", col0)


def icu_collate_chr(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_chr", col0)


def icu_collate_cs(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_cs", col0)


def icu_collate_cy(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_cy", col0)


def icu_collate_da(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_da", col0)


def icu_collate_de(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_de", col0)


def icu_collate_de_at(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_de_at", col0)


def icu_collate_dsb(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_dsb", col0)


def icu_collate_dz(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_dz", col0)


def icu_collate_ee(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_ee", col0)


def icu_collate_el(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_el", col0)


def icu_collate_en(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_en", col0)


def icu_collate_en_us(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_en_us", col0)


def icu_collate_eo(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_eo", col0)


def icu_collate_es(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_es", col0)


def icu_collate_et(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_et", col0)


def icu_collate_fa(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_fa", col0)


def icu_collate_fa_af(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_fa_af", col0)


def icu_collate_ff(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_ff", col0)


def icu_collate_fi(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_fi", col0)


def icu_collate_fil(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_fil", col0)


def icu_collate_fo(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_fo", col0)


def icu_collate_fr(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_fr", col0)


def icu_collate_fr_ca(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_fr_ca", col0)


def icu_collate_fy(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_fy", col0)


def icu_collate_ga(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_ga", col0)


def icu_collate_gl(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_gl", col0)


def icu_collate_gu(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_gu", col0)


def icu_collate_ha(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_ha", col0)


def icu_collate_haw(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_haw", col0)


def icu_collate_he(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_he", col0)


def icu_collate_he_il(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_he_il", col0)


def icu_collate_hi(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_hi", col0)


def icu_collate_hr(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_hr", col0)


def icu_collate_hsb(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_hsb", col0)


def icu_collate_hu(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_hu", col0)


def icu_collate_hy(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_hy", col0)


def icu_collate_id(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_id", col0)


def icu_collate_id_id(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_id_id", col0)


def icu_collate_ig(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_ig", col0)


def icu_collate_is(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_is", col0)


def icu_collate_it(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_it", col0)


def icu_collate_ja(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_ja", col0)


def icu_collate_ka(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_ka", col0)


def icu_collate_kk(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_kk", col0)


def icu_collate_kl(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_kl", col0)


def icu_collate_km(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_km", col0)


def icu_collate_kn(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_kn", col0)


def icu_collate_ko(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_ko", col0)


def icu_collate_kok(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_kok", col0)


def icu_collate_ku(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_ku", col0)


def icu_collate_ky(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_ky", col0)


def icu_collate_lb(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_lb", col0)


def icu_collate_lkt(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_lkt", col0)


def icu_collate_ln(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_ln", col0)


def icu_collate_lo(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_lo", col0)


def icu_collate_lt(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_lt", col0)


def icu_collate_lv(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_lv", col0)


def icu_collate_mk(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_mk", col0)


def icu_collate_ml(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_ml", col0)


def icu_collate_mn(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_mn", col0)


def icu_collate_mr(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_mr", col0)


def icu_collate_ms(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_ms", col0)


def icu_collate_mt(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_mt", col0)


def icu_collate_my(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_my", col0)


def icu_collate_nb(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_nb", col0)


def icu_collate_nb_no(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_nb_no", col0)


def icu_collate_ne(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_ne", col0)


def icu_collate_nl(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_nl", col0)


def icu_collate_nn(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_nn", col0)


def icu_collate_noaccent(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_noaccent", col0)


def icu_collate_om(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_om", col0)


def icu_collate_or(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_or", col0)


def icu_collate_pa(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_pa", col0)


def icu_collate_pa_in(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_pa_in", col0)


def icu_collate_pl(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_pl", col0)


def icu_collate_ps(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_ps", col0)


def icu_collate_pt(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_pt", col0)


def icu_collate_ro(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_ro", col0)


def icu_collate_ru(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_ru", col0)


def icu_collate_sa(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_sa", col0)


def icu_collate_se(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_se", col0)


def icu_collate_si(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_si", col0)


def icu_collate_sk(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_sk", col0)


def icu_collate_sl(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_sl", col0)


def icu_collate_smn(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_smn", col0)


def icu_collate_sq(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_sq", col0)


def icu_collate_sr(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_sr", col0)


def icu_collate_sr_ba(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_sr_ba", col0)


def icu_collate_sr_me(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_sr_me", col0)


def icu_collate_sr_rs(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_sr_rs", col0)


def icu_collate_sv(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_sv", col0)


def icu_collate_sw(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_sw", col0)


def icu_collate_ta(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_ta", col0)


def icu_collate_te(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_te", col0)


def icu_collate_th(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_th", col0)


def icu_collate_tk(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_tk", col0)


def icu_collate_to(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_to", col0)


def icu_collate_tr(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_tr", col0)


def icu_collate_ug(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_ug", col0)


def icu_collate_uk(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_uk", col0)


def icu_collate_ur(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_ur", col0)


def icu_collate_uz(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_uz", col0)


def icu_collate_vi(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_vi", col0)


def icu_collate_wae(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_wae", col0)


def icu_collate_wo(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_wo", col0)


def icu_collate_xh(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_xh", col0)


def icu_collate_yi(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_yi", col0)


def icu_collate_yo(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_yo", col0)


def icu_collate_yue(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_yue", col0)


def icu_collate_yue_cn(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_yue_cn", col0)


def icu_collate_zh(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_zh", col0)


def icu_collate_zh_cn(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_zh_cn", col0)


def icu_collate_zh_hk(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_zh_hk", col0)


def icu_collate_zh_mo(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_zh_mo", col0)


def icu_collate_zh_sg(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_zh_sg", col0)


def icu_collate_zh_tw(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_zh_tw", col0)


def icu_collate_zu(col0, /) -> Expression:
    """"""
    return FunctionExpression("icu_collate_zu", col0)


def icu_sort_key(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("icu_sort_key", col0, col1)


def ilike_escape(col0, col1, col2, /) -> Expression:
    """"""
    return FunctionExpression("ilike_escape", col0, col1, col2)


def in_search_path(database_name, schema_name, /) -> Expression:
    """Returns whether or not the database/schema are in the search path"""
    return FunctionExpression("in_search_path", database_name, schema_name)


def instr(haystack, needle, /) -> Expression:
    """Returns location of first occurrence of needle in haystack, counting from 1.
    Returns 0 if no match found"""
    return FunctionExpression("instr", haystack, needle)


def is_histogram_other_bin(val, /) -> Expression:
    """Whether or not the provided value is the histogram "other" bin (used for values
    not belonging to any provided bin)"""
    return FunctionExpression("is_histogram_other_bin", val)


def isfinite(x, /) -> Expression:
    """Returns true if the floating point value is finite, false otherwise"""
    return FunctionExpression("isfinite", x)


def isinf(x, /) -> Expression:
    """Returns true if the floating point value is infinite, false otherwise"""
    return FunctionExpression("isinf", x)


def isnan(x, /) -> Expression:
    """Returns true if the floating point value is not a number, false otherwise"""
    return FunctionExpression("isnan", x)


def isodow(ts, /) -> Expression:
    """Extract the isodow component from a date or timestamp"""
    return FunctionExpression("isodow", ts)


def isoyear(ts, /) -> Expression:
    """Extract the isoyear component from a date or timestamp"""
    return FunctionExpression("isoyear", ts)


def jaccard(str1, str2, /) -> Expression:
    """The Jaccard similarity between two strings. Different case is considered
    different. Returns a number between 0 and 1"""
    return FunctionExpression("jaccard", str1, str2)


def jaro_similarity(str1, str2, /) -> Expression:
    """The Jaro similarity between two strings. Different case is considered different.
    Returns a number between 0 and 1"""
    return FunctionExpression("jaro_similarity", str1, str2)


def jaro_winkler_similarity(str1, str2, /) -> Expression:
    """The Jaro-Winkler similarity between two strings. Different case is considered
    different. Returns a number between 0 and 1"""
    return FunctionExpression("jaro_winkler_similarity", str1, str2)


def json(x, /) -> Expression:
    """"""
    return FunctionExpression("json", x)


def json_array(*args) -> Expression:
    """"""
    return FunctionExpression("json_array", *args)


def json_array_length(col0, col1=_UNDEFINED, /) -> Expression:
    """"""
    return FunctionExpression("json_array_length", *_remove_undefined_parameters(col0, col1))


def json_contains(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("json_contains", col0, col1)


def json_deserialize_sql(col0, /) -> Expression:
    """"""
    return FunctionExpression("json_deserialize_sql", col0)


def json_exists(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("json_exists", col0, col1)


def json_extract(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("json_extract", col0, col1)


def json_extract_path(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("json_extract_path", col0, col1)


def json_extract_path_text(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("json_extract_path_text", col0, col1)


def json_extract_string(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("json_extract_string", col0, col1)


def json_group_array(x, /) -> Expression:
    """"""
    return FunctionExpression("json_group_array", x)


def json_group_object(name, value, /) -> Expression:
    """"""
    return FunctionExpression("json_group_object", name, value)


def json_group_structure(x, /) -> Expression:
    """"""
    return FunctionExpression("json_group_structure", x)


def json_keys(col0, col1=_UNDEFINED, /) -> Expression:
    """"""
    return FunctionExpression("json_keys", *_remove_undefined_parameters(col0, col1))


def json_merge_patch(*args) -> Expression:
    """"""
    return FunctionExpression("json_merge_patch", *args)


def json_object(*args) -> Expression:
    """"""
    return FunctionExpression("json_object", *args)


def json_pretty(col0, /) -> Expression:
    """"""
    return FunctionExpression("json_pretty", col0)


def json_quote(*args) -> Expression:
    """"""
    return FunctionExpression("json_quote", *args)


def json_serialize_plan(col0, col1=_UNDEFINED, col2=_UNDEFINED, col3=_UNDEFINED, col4=_UNDEFINED, /) -> Expression:
    """"""
    return FunctionExpression("json_serialize_plan", *_remove_undefined_parameters(col0, col1, col2, col3, col4))


def json_serialize_sql(col0, col1=_UNDEFINED, col2=_UNDEFINED, col3=_UNDEFINED, /) -> Expression:
    """"""
    return FunctionExpression("json_serialize_sql", *_remove_undefined_parameters(col0, col1, col2, col3))


def json_structure(col0, /) -> Expression:
    """"""
    return FunctionExpression("json_structure", col0)


def json_transform(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("json_transform", col0, col1)


def json_transform_strict(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("json_transform_strict", col0, col1)


def json_type(col0, col1=_UNDEFINED, /) -> Expression:
    """"""
    return FunctionExpression("json_type", *_remove_undefined_parameters(col0, col1))


def json_valid(col0, /) -> Expression:
    """"""
    return FunctionExpression("json_valid", col0)


def json_value(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("json_value", col0, col1)


def julian(ts, /) -> Expression:
    """Extract the Julian Day number from a date or timestamp"""
    return FunctionExpression("julian", ts)


def kahan_sum(arg, /) -> Expression:
    """Calculates the sum using a more accurate floating point summation (Kahan Sum)."""
    return FunctionExpression("kahan_sum", arg)


def kurtosis(x, /) -> Expression:
    """Returns the excess kurtosis (Fisher’s definition) of all input values, with a
    bias correction according to the sample size"""
    return FunctionExpression("kurtosis", x)


def kurtosis_pop(x, /) -> Expression:
    """Returns the excess kurtosis (Fisher’s definition) of all input values, without
    bias correction"""
    return FunctionExpression("kurtosis_pop", x)


def last(col0, /) -> Expression:
    """"""
    return FunctionExpression("last", col0)


def last_day(ts, /) -> Expression:
    """Returns the last day of the month"""
    return FunctionExpression("last_day", ts)


def lcase(col0, /) -> Expression:
    """"""
    return FunctionExpression("lcase", col0)


def lcm(x, y, /) -> Expression:
    """Computes the least common multiple of x and y"""
    return FunctionExpression("lcm", x, y)


def least(*args) -> Expression:
    """Returns the lowest value of the set of input parameters"""
    return FunctionExpression("least", *args)


def least_common_multiple(x, y, /) -> Expression:
    """Computes the least common multiple of x and y"""
    return FunctionExpression("least_common_multiple", x, y)


def left(string, count, /) -> Expression:
    """Extract the left-most count characters"""
    return FunctionExpression("left", string, count)


def left_grapheme(string, count, /) -> Expression:
    """Extract the left-most count grapheme clusters"""
    return FunctionExpression("left_grapheme", string, count)


def len(col0, /) -> Expression:
    """"""
    return FunctionExpression("len", col0)


def length(col0, /) -> Expression:
    """"""
    return FunctionExpression("length", col0)


def length_grapheme(col0, /) -> Expression:
    """"""
    return FunctionExpression("length_grapheme", col0)


def levenshtein(str1, str2, /) -> Expression:
    """The minimum number of single-character edits (insertions, deletions or
    substitutions) required to change one string to the other. Different case is
    considered different"""
    return FunctionExpression("levenshtein", str1, str2)


def lgamma(x, /) -> Expression:
    """Computes the log of the gamma function"""
    return FunctionExpression("lgamma", x)


def like_escape(col0, col1, col2, /) -> Expression:
    """"""
    return FunctionExpression("like_escape", col0, col1, col2)


def list(arg, /) -> Expression:
    """Returns a LIST containing all the values of a column."""
    return FunctionExpression("list", arg)


def list_aggr(*args) -> Expression:
    """Executes the aggregate function name on the elements of list"""
    return FunctionExpression("list_aggr", *args)


def list_aggregate(*args) -> Expression:
    """Executes the aggregate function name on the elements of list"""
    return FunctionExpression("list_aggregate", *args)


def list_any_value(l, /) -> Expression:
    """"""
    return FunctionExpression("list_any_value", l)


def list_append(l, e, /) -> Expression:
    """"""
    return FunctionExpression("list_append", l, e)


def list_approx_count_distinct(l, /) -> Expression:
    """"""
    return FunctionExpression("list_approx_count_distinct", l)


def list_avg(l, /) -> Expression:
    """"""
    return FunctionExpression("list_avg", l)


def list_bit_and(l, /) -> Expression:
    """"""
    return FunctionExpression("list_bit_and", l)


def list_bit_or(l, /) -> Expression:
    """"""
    return FunctionExpression("list_bit_or", l)


def list_bit_xor(l, /) -> Expression:
    """"""
    return FunctionExpression("list_bit_xor", l)


def list_bool_and(l, /) -> Expression:
    """"""
    return FunctionExpression("list_bool_and", l)


def list_bool_or(l, /) -> Expression:
    """"""
    return FunctionExpression("list_bool_or", l)


def list_cat(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("list_cat", col0, col1)


def list_concat(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("list_concat", col0, col1)


def list_contains(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("list_contains", col0, col1)


def list_cosine_distance(list1, list2, /) -> Expression:
    """Compute the cosine distance between two lists"""
    return FunctionExpression("list_cosine_distance", list1, list2)


def list_cosine_similarity(list1, list2, /) -> Expression:
    """Compute the cosine similarity between two lists"""
    return FunctionExpression("list_cosine_similarity", list1, list2)


def list_count(l, /) -> Expression:
    """"""
    return FunctionExpression("list_count", l)


def list_distance(list1, list2, /) -> Expression:
    """Compute the distance between two lists"""
    return FunctionExpression("list_distance", list1, list2)


def list_distinct(list, /) -> Expression:
    """Removes all duplicates and NULLs from a list. Does not preserve the original
    order"""
    return FunctionExpression("list_distinct", list)


def list_dot_product(list1, list2, /) -> Expression:
    """Compute the inner product between two lists"""
    return FunctionExpression("list_dot_product", list1, list2)


def list_element(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("list_element", col0, col1)


def list_entropy(l, /) -> Expression:
    """"""
    return FunctionExpression("list_entropy", l)


def list_extract(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("list_extract", col0, col1)


def list_first(l, /) -> Expression:
    """"""
    return FunctionExpression("list_first", l)


def list_grade_up(list, col1=_UNDEFINED, col2=_UNDEFINED, /) -> Expression:
    """Returns the index of their sorted position."""
    return FunctionExpression("list_grade_up", *_remove_undefined_parameters(list, col1, col2))


def list_has(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("list_has", col0, col1)


def list_has_all(l1, l2, /) -> Expression:
    """Returns true if all elements of l2 are in l1. NULLs are ignored."""
    return FunctionExpression("list_has_all", l1, l2)


def list_has_any(l1, l2, /) -> Expression:
    """Returns true if the lists have any element in common. NULLs are ignored."""
    return FunctionExpression("list_has_any", l1, l2)


def list_histogram(l, /) -> Expression:
    """"""
    return FunctionExpression("list_histogram", l)


def list_indexof(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("list_indexof", col0, col1)


def list_inner_product(list1, list2, /) -> Expression:
    """Compute the inner product between two lists"""
    return FunctionExpression("list_inner_product", list1, list2)


def list_intersect(l1, l2, /) -> Expression:
    """"""
    return FunctionExpression("list_intersect", l1, l2)


def list_kurtosis(l, /) -> Expression:
    """"""
    return FunctionExpression("list_kurtosis", l)


def list_kurtosis_pop(l, /) -> Expression:
    """"""
    return FunctionExpression("list_kurtosis_pop", l)


def list_last(l, /) -> Expression:
    """"""
    return FunctionExpression("list_last", l)


def list_mad(l, /) -> Expression:
    """"""
    return FunctionExpression("list_mad", l)


def list_max(l, /) -> Expression:
    """"""
    return FunctionExpression("list_max", l)


def list_median(l, /) -> Expression:
    """"""
    return FunctionExpression("list_median", l)


def list_min(l, /) -> Expression:
    """"""
    return FunctionExpression("list_min", l)


def list_mode(l, /) -> Expression:
    """"""
    return FunctionExpression("list_mode", l)


def list_negative_dot_product(list1, list2, /) -> Expression:
    """Compute the negative inner product between two lists"""
    return FunctionExpression("list_negative_dot_product", list1, list2)


def list_negative_inner_product(list1, list2, /) -> Expression:
    """Compute the negative inner product between two lists"""
    return FunctionExpression("list_negative_inner_product", list1, list2)


def list_pack(*args) -> Expression:
    """Create a LIST containing the argument values"""
    return FunctionExpression("list_pack", *args)


def list_position(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("list_position", col0, col1)


def list_prepend(e, l, /) -> Expression:
    """"""
    return FunctionExpression("list_prepend", e, l)


def list_product(l, /) -> Expression:
    """"""
    return FunctionExpression("list_product", l)


def list_resize(col0, col1, col2=_UNDEFINED, /) -> Expression:
    """"""
    return FunctionExpression("list_resize", *_remove_undefined_parameters(col0, col1, col2))


def list_reverse(l, /) -> Expression:
    """"""
    return FunctionExpression("list_reverse", l)


def list_reverse_sort(list, col1=_UNDEFINED, /) -> Expression:
    """Sorts the elements of the list in reverse order"""
    return FunctionExpression("list_reverse_sort", *_remove_undefined_parameters(list, col1))


def list_select(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("list_select", col0, col1)


def list_sem(l, /) -> Expression:
    """"""
    return FunctionExpression("list_sem", l)


def list_skewness(l, /) -> Expression:
    """"""
    return FunctionExpression("list_skewness", l)


def list_slice(list, begin, end, step=_UNDEFINED, /) -> Expression:
    """Extract a sublist using slice conventions. Negative values are accepted"""
    return FunctionExpression("list_slice", *_remove_undefined_parameters(list, begin, end, step))


def list_sort(list, col1=_UNDEFINED, col2=_UNDEFINED, /) -> Expression:
    """Sorts the elements of the list"""
    return FunctionExpression("list_sort", *_remove_undefined_parameters(list, col1, col2))


def list_stddev_pop(l, /) -> Expression:
    """"""
    return FunctionExpression("list_stddev_pop", l)


def list_stddev_samp(l, /) -> Expression:
    """"""
    return FunctionExpression("list_stddev_samp", l)


def list_string_agg(l, /) -> Expression:
    """"""
    return FunctionExpression("list_string_agg", l)


def list_sum(l, /) -> Expression:
    """"""
    return FunctionExpression("list_sum", l)


def list_unique(list, /) -> Expression:
    """Counts the unique elements of a list"""
    return FunctionExpression("list_unique", list)


def list_value(*args) -> Expression:
    """Create a LIST containing the argument values"""
    return FunctionExpression("list_value", *args)


def list_var_pop(l, /) -> Expression:
    """"""
    return FunctionExpression("list_var_pop", l)


def list_var_samp(l, /) -> Expression:
    """"""
    return FunctionExpression("list_var_samp", l)


def list_where(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("list_where", col0, col1)


def list_zip(*args) -> Expression:
    """"""
    return FunctionExpression("list_zip", *args)


def listagg(str, arg=_UNDEFINED, /) -> Expression:
    """Concatenates the column string values with an optional separator."""
    return FunctionExpression("listagg", *_remove_undefined_parameters(str, arg))


def ln(x, /) -> Expression:
    """Computes the natural logarithm of x"""
    return FunctionExpression("ln", x)


def log(b, x=_UNDEFINED, /) -> Expression:
    """Computes the logarithm of x to base b. b may be omitted, in which case the
    default 10"""
    return FunctionExpression("log", *_remove_undefined_parameters(b, x))


def log10(x, /) -> Expression:
    """Computes the 10-log of x"""
    return FunctionExpression("log10", x)


def log2(x, /) -> Expression:
    """Computes the 2-log of x"""
    return FunctionExpression("log2", x)


def lower(col0, /) -> Expression:
    """"""
    return FunctionExpression("lower", col0)


def lpad(string, count, character, /) -> Expression:
    """Pads the string with the character from the left until it has count characters"""
    return FunctionExpression("lpad", string, count, character)


def lsmode(col0, /) -> Expression:
    """"""
    return FunctionExpression("lsmode", col0)


def ltrim(string, characters=_UNDEFINED, /) -> Expression:
    """Removes any occurrences of any of the characters from the left side of the
    string"""
    return FunctionExpression("ltrim", *_remove_undefined_parameters(string, characters))


def mad(x, /) -> Expression:
    """Returns the median absolute deviation for the values within x. NULL values are
    ignored. Temporal types return a positive INTERVAL."""
    return FunctionExpression("mad", x)


def make_date(year, month=_UNDEFINED, day=_UNDEFINED, /) -> Expression:
    """The date for the given parts"""
    return FunctionExpression("make_date", *_remove_undefined_parameters(year, month, day))


def make_time(hour, minute, seconds, /) -> Expression:
    """The time for the given parts"""
    return FunctionExpression("make_time", hour, minute, seconds)


def make_timestamp(year, month=_UNDEFINED, day=_UNDEFINED, hour=_UNDEFINED, minute=_UNDEFINED, seconds=_UNDEFINED, /) -> Expression:
    """The timestamp for the given parts"""
    return FunctionExpression("make_timestamp", *_remove_undefined_parameters(year, month, day, hour, minute, seconds))


def make_timestamptz(col0, col1=_UNDEFINED, col2=_UNDEFINED, col3=_UNDEFINED, col4=_UNDEFINED, col5=_UNDEFINED, col6=_UNDEFINED, /) -> Expression:
    """"""
    return FunctionExpression("make_timestamptz", *_remove_undefined_parameters(col0, col1, col2, col3, col4, col5, col6))


def map(*args) -> Expression:
    """Creates a map from a set of keys and values"""
    return FunctionExpression("map", *args)


def map_concat(*args) -> Expression:
    """Returns a map created from merging the input maps, on key collision the value is
    taken from the last map with that key"""
    return FunctionExpression("map_concat", *args)


def map_contains(map, key, /) -> Expression:
    """Returns true if the map contains the key, false otherwise"""
    return FunctionExpression("map_contains", map, key)


def map_contains_entry(map, key, value, /) -> Expression:
    """"""
    return FunctionExpression("map_contains_entry", map, key, value)


def map_contains_value(map, value, /) -> Expression:
    """"""
    return FunctionExpression("map_contains_value", map, value)


def map_entries(*args) -> Expression:
    """Returns the map entries as a list of keys/values"""
    return FunctionExpression("map_entries", *args)


def map_extract(*args) -> Expression:
    """Returns a list containing the value for a given key or an empty list if the key
    is not contained in the map. The type of the key provided in the second
    parameter must match the type of the map’s keys else an error is returned"""
    return FunctionExpression("map_extract", *args)


def map_from_entries(*args) -> Expression:
    """Returns a map created from the entries of the array"""
    return FunctionExpression("map_from_entries", *args)


def map_keys(*args) -> Expression:
    """Returns the keys of a map as a list"""
    return FunctionExpression("map_keys", *args)


def map_values(*args) -> Expression:
    """Returns the values of a map as a list"""
    return FunctionExpression("map_values", *args)


def max(arg, col1=_UNDEFINED, /) -> Expression:
    """Returns the maximum value present in arg."""
    return FunctionExpression("max", *_remove_undefined_parameters(arg, col1))


def max_by(arg, val, col2=_UNDEFINED, /) -> Expression:
    """Finds the row with the maximum val. Calculates the non-NULL arg expression at
    that row."""
    return FunctionExpression("max_by", *_remove_undefined_parameters(arg, val, col2))


def md5(value, /) -> Expression:
    """Returns the MD5 hash of the value as a string"""
    return FunctionExpression("md5", value)


def md5_number(value, /) -> Expression:
    """Returns the MD5 hash of the value as an INT128"""
    return FunctionExpression("md5_number", value)


def md5_number_lower(param, /) -> Expression:
    """"""
    return FunctionExpression("md5_number_lower", param)


def md5_number_upper(param, /) -> Expression:
    """"""
    return FunctionExpression("md5_number_upper", param)


def mean(x, /) -> Expression:
    """Calculates the average value for all tuples in x."""
    return FunctionExpression("mean", x)


def median(x, /) -> Expression:
    """Returns the middle value of the set. NULL values are ignored. For even value
    counts, quantitative values are averaged and ordinal values return the lower
    value."""
    return FunctionExpression("median", x)


def microsecond(ts, /) -> Expression:
    """Extract the microsecond component from a date or timestamp"""
    return FunctionExpression("microsecond", ts)


def millennium(ts, /) -> Expression:
    """Extract the millennium component from a date or timestamp"""
    return FunctionExpression("millennium", ts)


def millisecond(ts, /) -> Expression:
    """Extract the millisecond component from a date or timestamp"""
    return FunctionExpression("millisecond", ts)


def min(arg, col1=_UNDEFINED, /) -> Expression:
    """Returns the minimum value present in arg."""
    return FunctionExpression("min", *_remove_undefined_parameters(arg, col1))


def min_by(arg, val, col2=_UNDEFINED, /) -> Expression:
    """Finds the row with the minimum val. Calculates the non-NULL arg expression at
    that row."""
    return FunctionExpression("min_by", *_remove_undefined_parameters(arg, val, col2))


def minute(ts, /) -> Expression:
    """Extract the minute component from a date or timestamp"""
    return FunctionExpression("minute", ts)


def mismatches(str1, str2, /) -> Expression:
    """The number of positions with different characters for 2 strings of equal length.
    Different case is considered different"""
    return FunctionExpression("mismatches", str1, str2)


def mod(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("mod", col0, col1)


def mode(x, /) -> Expression:
    """Returns the most frequent value for the values within x. NULL values are
    ignored."""
    return FunctionExpression("mode", x)


def month(ts, /) -> Expression:
    """Extract the month component from a date or timestamp"""
    return FunctionExpression("month", ts)


def monthname(ts, /) -> Expression:
    """The (English) name of the month"""
    return FunctionExpression("monthname", ts)


def multiply(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("multiply", col0, col1)


def nanosecond(tsns, /) -> Expression:
    """Extract the nanosecond component from a date or timestamp"""
    return FunctionExpression("nanosecond", tsns)


def nextafter(x, y, /) -> Expression:
    """Returns the next floating point value after x in the direction of y"""
    return FunctionExpression("nextafter", x, y)


def nextval(col0, /) -> Expression:
    """"""
    return FunctionExpression("nextval", col0)


def nfc_normalize(col0, /) -> Expression:
    """"""
    return FunctionExpression("nfc_normalize", col0)


def not_ilike_escape(col0, col1, col2, /) -> Expression:
    """"""
    return FunctionExpression("not_ilike_escape", col0, col1, col2)


def not_like_escape(col0, col1, col2, /) -> Expression:
    """"""
    return FunctionExpression("not_like_escape", col0, col1, col2)


def now() -> Expression:
    """Returns the current timestamp"""
    return FunctionExpression("now")


def nullif(a, b, /) -> Expression:
    """"""
    return FunctionExpression("nullif", a, b)


def octet_length(col0, /) -> Expression:
    """"""
    return FunctionExpression("octet_length", col0)


def ord(str, /) -> Expression:
    """Returns the unicode codepoint of the first character of the string"""
    return FunctionExpression("ord", str)


def parse_dirname(string, separator=_UNDEFINED, /) -> Expression:
    """Returns the top-level directory name. separator options: system, both_slash
    (default), forward_slash, backslash"""
    return FunctionExpression("parse_dirname", *_remove_undefined_parameters(string, separator))


def parse_dirpath(string, separator=_UNDEFINED, /) -> Expression:
    """Returns the head of the path similarly to Python's os.path.dirname. separator
    options: system, both_slash (default), forward_slash, backslash"""
    return FunctionExpression("parse_dirpath", *_remove_undefined_parameters(string, separator))


def parse_filename(string, trim_extension=_UNDEFINED, separator=_UNDEFINED, /) -> Expression:
    """Returns the last component of the path similarly to Python's os.path.basename.
    If trim_extension is true, the file extension will be removed (it defaults
    to false). separator options: system, both_slash (default), forward_slash,
    backslash"""
    return FunctionExpression("parse_filename", *_remove_undefined_parameters(string, trim_extension, separator))


def parse_path(string, separator=_UNDEFINED, /) -> Expression:
    """Returns a list of the components (directories and filename) in the path
    similarly to Python's pathlib.PurePath::parts. separator options: system,
    both_slash (default), forward_slash, backslash"""
    return FunctionExpression("parse_path", *_remove_undefined_parameters(string, separator))


def pi() -> Expression:
    """Returns the value of pi"""
    return FunctionExpression("pi")


def position(haystack, needle, /) -> Expression:
    """Returns location of first occurrence of needle in haystack, counting from 1.
    Returns 0 if no match found"""
    return FunctionExpression("position", haystack, needle)


def pow(x, y, /) -> Expression:
    """Computes x to the power of y"""
    return FunctionExpression("pow", x, y)


def power(x, y, /) -> Expression:
    """Computes x to the power of y"""
    return FunctionExpression("power", x, y)


def prefix(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("prefix", col0, col1)


def printf(*args) -> Expression:
    """Formats a string using printf syntax"""
    return FunctionExpression("printf", *args)


def product(arg, /) -> Expression:
    """Calculates the product of all tuples in arg."""
    return FunctionExpression("product", arg)


def quantile(x, pos=_UNDEFINED, /) -> Expression:
    """Returns the exact quantile number between 0 and 1 . If pos is a LIST of FLOATs,
    then the result is a LIST of the corresponding exact quantiles."""
    return FunctionExpression("quantile", *_remove_undefined_parameters(x, pos))


def quantile_cont(x, pos, /) -> Expression:
    """Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of
    FLOATs, then the result is a LIST of the corresponding interpolated
    quantiles."""
    return FunctionExpression("quantile_cont", x, pos)


def quantile_disc(x, pos=_UNDEFINED, /) -> Expression:
    """Returns the exact quantile number between 0 and 1 . If pos is a LIST of FLOATs,
    then the result is a LIST of the corresponding exact quantiles."""
    return FunctionExpression("quantile_disc", *_remove_undefined_parameters(x, pos))


def quarter(ts, /) -> Expression:
    """Extract the quarter component from a date or timestamp"""
    return FunctionExpression("quarter", ts)


def radians(x, /) -> Expression:
    """Converts degrees to radians"""
    return FunctionExpression("radians", x)


def random() -> Expression:
    """Returns a random number between 0 and 1"""
    return FunctionExpression("random")


def range(start, stop=_UNDEFINED, step=_UNDEFINED, /) -> Expression:
    """Create a list of values between start and stop - the stop parameter is exclusive"""
    return FunctionExpression("range", *_remove_undefined_parameters(start, stop, step))


def readfile(col0, /) -> Expression:
    """"""
    return FunctionExpression("readfile", col0)


def regexp_escape(string, /) -> Expression:
    """Escapes all potentially meaningful regexp characters in the input string"""
    return FunctionExpression("regexp_escape", string)


def regexp_extract(col0, col1, col2=_UNDEFINED, col3=_UNDEFINED, /) -> Expression:
    """"""
    return FunctionExpression("regexp_extract", *_remove_undefined_parameters(col0, col1, col2, col3))


def regexp_extract_all(col0, col1, col2=_UNDEFINED, col3=_UNDEFINED, /) -> Expression:
    """"""
    return FunctionExpression("regexp_extract_all", *_remove_undefined_parameters(col0, col1, col2, col3))


def regexp_full_match(col0, col1, col2=_UNDEFINED, /) -> Expression:
    """"""
    return FunctionExpression("regexp_full_match", *_remove_undefined_parameters(col0, col1, col2))


def regexp_matches(col0, col1, col2=_UNDEFINED, /) -> Expression:
    """"""
    return FunctionExpression("regexp_matches", *_remove_undefined_parameters(col0, col1, col2))


def regexp_replace(col0, col1, col2, col3=_UNDEFINED, /) -> Expression:
    """"""
    return FunctionExpression("regexp_replace", *_remove_undefined_parameters(col0, col1, col2, col3))


def regexp_split_to_array(string, separator, col2=_UNDEFINED, /) -> Expression:
    """Splits the string along the regex"""
    return FunctionExpression("regexp_split_to_array", *_remove_undefined_parameters(string, separator, col2))


def regexp_split_to_table(text, pattern, /) -> Expression:
    """"""
    return FunctionExpression("regexp_split_to_table", text, pattern)


def regr_avgx(y, x, /) -> Expression:
    """Returns the average of the independent variable for non-null pairs in a group,
    where x is the independent variable and y is the dependent variable."""
    return FunctionExpression("regr_avgx", y, x)


def regr_avgy(y, x, /) -> Expression:
    """Returns the average of the dependent variable for non-null pairs in a group,
    where x is the independent variable and y is the dependent variable."""
    return FunctionExpression("regr_avgy", y, x)


def regr_count(y, x, /) -> Expression:
    """Returns the number of non-null number pairs in a group."""
    return FunctionExpression("regr_count", y, x)


def regr_intercept(y, x, /) -> Expression:
    """Returns the intercept of the univariate linear regression line for non-null
    pairs in a group."""
    return FunctionExpression("regr_intercept", y, x)


def regr_r2(y, x, /) -> Expression:
    """Returns the coefficient of determination for non-null pairs in a group."""
    return FunctionExpression("regr_r2", y, x)


def regr_slope(y, x, /) -> Expression:
    """Returns the slope of the linear regression line for non-null pairs in a group."""
    return FunctionExpression("regr_slope", y, x)


def regr_sxx(y, x, /) -> Expression:
    """"""
    return FunctionExpression("regr_sxx", y, x)


def regr_sxy(y, x, /) -> Expression:
    """Returns the population covariance of input values"""
    return FunctionExpression("regr_sxy", y, x)


def regr_syy(y, x, /) -> Expression:
    """"""
    return FunctionExpression("regr_syy", y, x)


def repeat(string, count, /) -> Expression:
    """Repeats the string count number of times"""
    return FunctionExpression("repeat", string, count)


def replace(string, source, target, /) -> Expression:
    """Replaces any occurrences of the source with target in string"""
    return FunctionExpression("replace", string, source, target)


def reservoir_quantile(x, quantile, sample_size=_UNDEFINED, /) -> Expression:
    """Gives the approximate quantile using reservoir sampling, the sample size is
    optional and uses 8192 as a default size."""
    return FunctionExpression("reservoir_quantile", *_remove_undefined_parameters(x, quantile, sample_size))


def reverse(string, /) -> Expression:
    """Reverses the string"""
    return FunctionExpression("reverse", string)


def right(string, count, /) -> Expression:
    """Extract the right-most count characters"""
    return FunctionExpression("right", string, count)


def right_grapheme(string, count, /) -> Expression:
    """Extract the right-most count grapheme clusters"""
    return FunctionExpression("right_grapheme", string, count)


def round(x, precision=_UNDEFINED, /) -> Expression:
    """Rounds x to s decimal places"""
    return FunctionExpression("round", *_remove_undefined_parameters(x, precision))


def round_even(x, n, /) -> Expression:
    """"""
    return FunctionExpression("round_even", x, n)


def roundbankers(x, n, /) -> Expression:
    """"""
    return FunctionExpression("roundbankers", x, n)


def row(*args) -> Expression:
    """Creates an unnamed STRUCT containing the argument values."""
    return FunctionExpression("row", *args)


def row_to_json(*args) -> Expression:
    """"""
    return FunctionExpression("row_to_json", *args)


def rpad(string, count, character, /) -> Expression:
    """Pads the string with the character from the right until it has count characters"""
    return FunctionExpression("rpad", string, count, character)


def rtrim(string, characters=_UNDEFINED, /) -> Expression:
    """Removes any occurrences of any of the characters from the right side of the
    string"""
    return FunctionExpression("rtrim", *_remove_undefined_parameters(string, characters))


def second(ts, /) -> Expression:
    """Extract the second component from a date or timestamp"""
    return FunctionExpression("second", ts)


def sem(x, /) -> Expression:
    """Returns the standard error of the mean"""
    return FunctionExpression("sem", x)


def session_user() -> Expression:
    """"""
    return FunctionExpression("session_user")


def set_bit(bitstring, index, new_value, /) -> Expression:
    """Sets the nth bit in bitstring to newvalue; the first (leftmost) bit is indexed
    0. Returns a new bitstring"""
    return FunctionExpression("set_bit", bitstring, index, new_value)


def setseed() -> Expression:
    """Sets the seed to be used for the random function"""
    return FunctionExpression("setseed")


def sha1(value, /) -> Expression:
    """Returns the SHA1 hash of the value"""
    return FunctionExpression("sha1", value)


def sha256(value, /) -> Expression:
    """Returns the SHA256 hash of the value"""
    return FunctionExpression("sha256", value)


def sha3(col0, col1=_UNDEFINED, /) -> Expression:
    """"""
    return FunctionExpression("sha3", *_remove_undefined_parameters(col0, col1))


def shell_add_schema(col0, col1, col2, /) -> Expression:
    """"""
    return FunctionExpression("shell_add_schema", col0, col1, col2)


def shell_escape_crnl(col0, /) -> Expression:
    """"""
    return FunctionExpression("shell_escape_crnl", col0)


def shell_idquote(col0, /) -> Expression:
    """"""
    return FunctionExpression("shell_idquote", col0)


def shell_module_schema(col0, /) -> Expression:
    """"""
    return FunctionExpression("shell_module_schema", col0)


def shell_putsnl(col0, /) -> Expression:
    """"""
    return FunctionExpression("shell_putsnl", col0)


def sign(x, /) -> Expression:
    """Returns the sign of x as -1, 0 or 1"""
    return FunctionExpression("sign", x)


def signbit(x, /) -> Expression:
    """Returns whether the signbit is set or not"""
    return FunctionExpression("signbit", x)


def sin(x, /) -> Expression:
    """Computes the sin of x"""
    return FunctionExpression("sin", x)


def sinh(x, /) -> Expression:
    """Computes the hyperbolic sin of x"""
    return FunctionExpression("sinh", x)


def skewness(x, /) -> Expression:
    """Returns the skewness of all input values."""
    return FunctionExpression("skewness", x)


def split(string, separator, /) -> Expression:
    """Splits the string along the separator"""
    return FunctionExpression("split", string, separator)


def split_part(string, delimiter, position, /) -> Expression:
    """"""
    return FunctionExpression("split_part", string, delimiter, position)


def sqrt(x, /) -> Expression:
    """Returns the square root of x"""
    return FunctionExpression("sqrt", x)


def starts_with(string, search_string, /) -> Expression:
    """Returns true if string begins with search_string"""
    return FunctionExpression("starts_with", string, search_string)


def stats(expression, /) -> Expression:
    """Returns a string with statistics about the expression. Expression can be a
    column, constant, or SQL expression"""
    return FunctionExpression("stats", expression)


def stddev(x, /) -> Expression:
    """Returns the sample standard deviation"""
    return FunctionExpression("stddev", x)


def stddev_pop(x, /) -> Expression:
    """Returns the population standard deviation."""
    return FunctionExpression("stddev_pop", x)


def stddev_samp(x, /) -> Expression:
    """Returns the sample standard deviation"""
    return FunctionExpression("stddev_samp", x)


def stem(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("stem", col0, col1)


def str_split(string, separator, /) -> Expression:
    """Splits the string along the separator"""
    return FunctionExpression("str_split", string, separator)


def str_split_regex(string, separator, col2=_UNDEFINED, /) -> Expression:
    """Splits the string along the regex"""
    return FunctionExpression("str_split_regex", *_remove_undefined_parameters(string, separator, col2))


def strftime(text, format, /) -> Expression:
    """Converts timestamp to string according to the format string"""
    return FunctionExpression("strftime", text, format)


def string_agg(str, arg=_UNDEFINED, /) -> Expression:
    """Concatenates the column string values with an optional separator."""
    return FunctionExpression("string_agg", *_remove_undefined_parameters(str, arg))


def string_split(string, separator, /) -> Expression:
    """Splits the string along the separator"""
    return FunctionExpression("string_split", string, separator)


def string_split_regex(string, separator, col2=_UNDEFINED, /) -> Expression:
    """Splits the string along the regex"""
    return FunctionExpression("string_split_regex", *_remove_undefined_parameters(string, separator, col2))


def string_to_array(string, separator, /) -> Expression:
    """Splits the string along the separator"""
    return FunctionExpression("string_to_array", string, separator)


def strip_accents(col0, /) -> Expression:
    """"""
    return FunctionExpression("strip_accents", col0)


def strlen(col0, /) -> Expression:
    """"""
    return FunctionExpression("strlen", col0)


def strpos(haystack, needle, /) -> Expression:
    """Returns location of first occurrence of needle in haystack, counting from 1.
    Returns 0 if no match found"""
    return FunctionExpression("strpos", haystack, needle)


def strptime(text, format, /) -> Expression:
    """Converts string to timestamp with time zone according to the format string if %Z
    is specified"""
    return FunctionExpression("strptime", text, format)


def struct_extract(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("struct_extract", col0, col1)


def struct_insert(*args) -> Expression:
    """Adds field(s)/value(s) to an existing STRUCT with the argument values. The entry
    name(s) will be the bound variable name(s)"""
    return FunctionExpression("struct_insert", *args)


def struct_pack(*args) -> Expression:
    """Creates a STRUCT containing the argument values. The entry name will be the
    bound variable name"""
    return FunctionExpression("struct_pack", *args)


def substr(col0, col1, col2=_UNDEFINED, /) -> Expression:
    """"""
    return FunctionExpression("substr", *_remove_undefined_parameters(col0, col1, col2))


def substring(col0, col1, col2=_UNDEFINED, /) -> Expression:
    """"""
    return FunctionExpression("substring", *_remove_undefined_parameters(col0, col1, col2))


def substring_grapheme(col0, col1, col2=_UNDEFINED, /) -> Expression:
    """"""
    return FunctionExpression("substring_grapheme", *_remove_undefined_parameters(col0, col1, col2))


def subtract(col0, col1=_UNDEFINED, /) -> Expression:
    """"""
    return FunctionExpression("subtract", *_remove_undefined_parameters(col0, col1))


def suffix(col0, col1, /) -> Expression:
    """"""
    return FunctionExpression("suffix", col0, col1)


def sum(arg, /) -> Expression:
    """Calculates the sum value for all tuples in arg."""
    return FunctionExpression("sum", arg)


def sum_no_overflow(arg, /) -> Expression:
    """Internal only. Calculates the sum value for all tuples in arg without overflow
    checks."""
    return FunctionExpression("sum_no_overflow", arg)


def sumkahan(arg, /) -> Expression:
    """Calculates the sum using a more accurate floating point summation (Kahan Sum)."""
    return FunctionExpression("sumkahan", arg)


def tan(x, /) -> Expression:
    """Computes the tan of x"""
    return FunctionExpression("tan", x)


def tanh(x, /) -> Expression:
    """Computes the hyperbolic tan of x"""
    return FunctionExpression("tanh", x)


def time_bucket(bucket_width, timestamp, origin=_UNDEFINED, /) -> Expression:
    """Truncate TIMESTAMPTZ by the specified interval bucket_width. Buckets are aligned
    relative to origin TIMESTAMPTZ. The origin defaults to 2000-01-03
    00:00:00+00 for buckets that do not include a month or year interval, and to
    2000-01-01 00:00:00+00 for month and year buckets"""
    return FunctionExpression("time_bucket", *_remove_undefined_parameters(bucket_width, timestamp, origin))


def timetz_byte_comparable(time_tz, /) -> Expression:
    """Converts a TIME WITH TIME ZONE to an integer sort key"""
    return FunctionExpression("timetz_byte_comparable", time_tz)


def timezone(ts, col1=_UNDEFINED, /) -> Expression:
    """Extract the timezone component from a date or timestamp"""
    return FunctionExpression("timezone", *_remove_undefined_parameters(ts, col1))


def timezone_hour(ts, /) -> Expression:
    """Extract the timezone_hour component from a date or timestamp"""
    return FunctionExpression("timezone_hour", ts)


def timezone_minute(ts, /) -> Expression:
    """Extract the timezone_minute component from a date or timestamp"""
    return FunctionExpression("timezone_minute", ts)


def to_base(number, radix, min_length=_UNDEFINED, /) -> Expression:
    """Converts a value to a string in the given base radix, optionally padding with
    leading zeros to the minimum length"""
    return FunctionExpression("to_base", *_remove_undefined_parameters(number, radix, min_length))


def to_base64(blob, /) -> Expression:
    """Convert a blob to a base64 encoded string"""
    return FunctionExpression("to_base64", blob)


def to_binary(value, /) -> Expression:
    """Converts the value to binary representation"""
    return FunctionExpression("to_binary", value)


def to_centuries(integer, /) -> Expression:
    """Construct a century interval"""
    return FunctionExpression("to_centuries", integer)


def to_days(integer, /) -> Expression:
    """Construct a day interval"""
    return FunctionExpression("to_days", integer)


def to_decades(integer, /) -> Expression:
    """Construct a decade interval"""
    return FunctionExpression("to_decades", integer)


def to_hex(value, /) -> Expression:
    """Converts the value to hexadecimal representation"""
    return FunctionExpression("to_hex", value)


def to_hours(integer, /) -> Expression:
    """Construct a hour interval"""
    return FunctionExpression("to_hours", integer)


def to_json(*args) -> Expression:
    """"""
    return FunctionExpression("to_json", *args)


def to_microseconds(integer, /) -> Expression:
    """Construct a microsecond interval"""
    return FunctionExpression("to_microseconds", integer)


def to_millennia(integer, /) -> Expression:
    """Construct a millenium interval"""
    return FunctionExpression("to_millennia", integer)


def to_milliseconds(double, /) -> Expression:
    """Construct a millisecond interval"""
    return FunctionExpression("to_milliseconds", double)


def to_minutes(integer, /) -> Expression:
    """Construct a minute interval"""
    return FunctionExpression("to_minutes", integer)


def to_months(integer, /) -> Expression:
    """Construct a month interval"""
    return FunctionExpression("to_months", integer)


def to_quarters(integer, /) -> Expression:
    """Construct a quarter interval"""
    return FunctionExpression("to_quarters", integer)


def to_seconds(double, /) -> Expression:
    """Construct a second interval"""
    return FunctionExpression("to_seconds", double)


def to_timestamp(sec, /) -> Expression:
    """Converts secs since epoch to a timestamp with time zone"""
    return FunctionExpression("to_timestamp", sec)


def to_weeks(integer, /) -> Expression:
    """Construct a week interval"""
    return FunctionExpression("to_weeks", integer)


def to_years(integer, /) -> Expression:
    """Construct a year interval"""
    return FunctionExpression("to_years", integer)


def today() -> Expression:
    """Returns the current date"""
    return FunctionExpression("today")


def transaction_timestamp() -> Expression:
    """Returns the current timestamp"""
    return FunctionExpression("transaction_timestamp")


def translate(string, from_, to, /) -> Expression:
    """Replaces each character in string that matches a character in the from set with
    the corresponding character in the to set. If from is longer than to,
    occurrences of the extra characters in from are deleted"""
    return FunctionExpression("translate", string, from_, to)


def trim(string, characters=_UNDEFINED, /) -> Expression:
    """Removes any occurrences of any of the characters from either side of the string"""
    return FunctionExpression("trim", *_remove_undefined_parameters(string, characters))


def trunc(x, /) -> Expression:
    """Truncates the number"""
    return FunctionExpression("trunc", x)


def try_strptime(text, format, /) -> Expression:
    """Converts string to timestamp using the format string (timestamp with time zone
    if %Z is specified). Returns NULL on failure"""
    return FunctionExpression("try_strptime", text, format)


def txid_current() -> Expression:
    """Returns the current transaction’s ID (a BIGINT). It will assign a new one if the
    current transaction does not have one already"""
    return FunctionExpression("txid_current")


def typeof(expression, /) -> Expression:
    """Returns the name of the data type of the result of the expression"""
    return FunctionExpression("typeof", expression)


def ucase(col0, /) -> Expression:
    """"""
    return FunctionExpression("ucase", col0)


def unbin(value, /) -> Expression:
    """Converts a value from binary representation to a blob"""
    return FunctionExpression("unbin", value)


def unhex(value, /) -> Expression:
    """Converts a value from hexadecimal representation to a blob"""
    return FunctionExpression("unhex", value)


def unicode(str, /) -> Expression:
    """Returns the unicode codepoint of the first character of the string"""
    return FunctionExpression("unicode", str)


def union_extract(union, tag, /) -> Expression:
    """Extract the value with the named tags from the union. NULL if the tag is not
    currently selected"""
    return FunctionExpression("union_extract", union, tag)


def union_tag(union, /) -> Expression:
    """Retrieve the currently selected tag of the union as an ENUM"""
    return FunctionExpression("union_tag", union)


def union_value(*args) -> Expression:
    """Create a single member UNION containing the argument value. The tag of the value
    will be the bound variable name"""
    return FunctionExpression("union_value", *args)


def unpivot_list(*args) -> Expression:
    """Identical to list_value, but generated as part of unpivot for better error
    messages"""
    return FunctionExpression("unpivot_list", *args)


def upper(col0, /) -> Expression:
    """"""
    return FunctionExpression("upper", col0)


def url_decode(input, /) -> Expression:
    """Unescapes the URL encoded input."""
    return FunctionExpression("url_decode", input)


def url_encode(input, /) -> Expression:
    """Escapes the input string by encoding it so that it can be included in a URL
    query parameter."""
    return FunctionExpression("url_encode", input)


def user() -> Expression:
    """"""
    return FunctionExpression("user")


def uuid() -> Expression:
    """Returns a random UUID similar to this: eeccb8c5-9943-b2bb-bb5e-222f4e14b687"""
    return FunctionExpression("uuid")


def var_pop(x, /) -> Expression:
    """Returns the population variance."""
    return FunctionExpression("var_pop", x)


def var_samp(x, /) -> Expression:
    """Returns the sample variance of all input values."""
    return FunctionExpression("var_samp", x)


def variance(x, /) -> Expression:
    """Returns the sample variance of all input values."""
    return FunctionExpression("variance", x)


def vector_type(col, /) -> Expression:
    """Returns the VectorType of a given column"""
    return FunctionExpression("vector_type", col)


def version() -> Expression:
    """Returns the currently active version of DuckDB in this format: v0.3.2"""
    return FunctionExpression("version")


def week(ts, /) -> Expression:
    """Extract the week component from a date or timestamp"""
    return FunctionExpression("week", ts)


def weekday(ts, /) -> Expression:
    """Extract the weekday component from a date or timestamp"""
    return FunctionExpression("weekday", ts)


def weekofyear(ts, /) -> Expression:
    """Extract the weekofyear component from a date or timestamp"""
    return FunctionExpression("weekofyear", ts)


def writefile(*args) -> Expression:
    """"""
    return FunctionExpression("writefile", *args)


def xor(left, right, /) -> Expression:
    """Bitwise XOR"""
    return FunctionExpression("xor", left, right)


def year(ts, /) -> Expression:
    """Extract the year component from a date or timestamp"""
    return FunctionExpression("year", ts)


def yearweek(ts, /) -> Expression:
    """Extract the yearweek component from a date or timestamp"""
    return FunctionExpression("yearweek", ts)
